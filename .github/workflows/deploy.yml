name: Deploy Zvonilka

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

# Не пускаем параллельные деплои одной и той же ветки
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read

env:
  NODE_VERSION: "20.x"         # при необходимости поменяй
  BUILD_DIR: "dist"            # куда билдит фронт (Vite/Parcel/webpack)
  # Ниже имена secrets, которые нужно завести в GitHub → Settings → Secrets and variables → Actions
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_PORT: ${{ secrets.SSH_PORT }}
  DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
  SERVICE_NAME: ${{ secrets.SERVICE_NAME }} # опционально: systemd unit для сигнального сервера (например, zvonilka-signal.service)

jobs:
  build-and-deploy:
    name: Build & Deploy over SSH
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install deps (ci)
        run: npm ci

      - name: Build
        run: npm run build

      # Поднимаем ssh-agent и кладём приватный ключ из секрета SSH_KEY
      # Ранее была ошибка: "The ssh-private-key argument is empty..." — это как раз отсюда,
      # если секрет не создан/неверно назван. Должен существовать secret с ИМЕНЕМ SSH_KEY.
      - name: Load SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      # Добавляем host key, чтобы не отключать StrictHostKeyChecking
      - name: Add known_hosts
        if: env.SSH_HOST != ''
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "${SSH_PORT:-22}" -H "${SSH_HOST}" >> ~/.ssh/known_hosts

      # Создаём директорию назначения, если её нет (на сервере)
      - name: Ensure deploy directory exists on server
        if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
        run: |
          ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" "mkdir -p '${DEPLOY_PATH}'"

      # Синхронизация артефактов билда (dist) на сервер через rsync поверх SSH
      - name: Rsync build to server
        if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
        run: |
          rsync -az --delete \
            -e "ssh -p ${SSH_PORT:-22}" \
            "${BUILD_DIR}/" \
            "${SSH_USER}@${SSH_HOST}:${DEPLOY_PATH}/"

      - name: Upload server files (server.js, package.json, lock, ecosystem)
        if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
        run: |
          rsync -az -e "ssh -p ${SSH_PORT:-22}" \
            server.js package.json package-lock.json ecosystem.config.js \
            "${SSH_USER}@${SSH_HOST}:${DEPLOY_PATH}/" || true

      - name: Install server runtime deps on host (npm ci --omit=dev)
        if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
        run: |
          ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" "\
            set -e; \
            cd '${DEPLOY_PATH}' || exit 0; \
            if [ -f package.json ]; then \
              npm ci --omit=dev; \
            fi
          "

      - name: Host | ensure dotenv and system env
        if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
        env:
          SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
          TURN_SECRET:   ${{ secrets.TURN_SECRET }}
        run: |
          ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" "\
            set -e; \
            cd '${DEPLOY_PATH}'; \
            if [ -f package.json ]; then npm i dotenv --save; fi; \
            echo \"$SUDO_PASSWORD\" | sudo -S bash -lc 'printf "TURN_SECRET=%s\n" "$TURN_SECRET" > /etc/call-signal.env'; \
          "

      - name: Host | install coturn config from repo
        if: env.SSH_HOST != ''
        env:
          SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
          TURN_SECRET:   ${{ secrets.TURN_SECRET }}
          TURN_IP:       ${{ secrets.TURN_IP }}
          TURN_IP2:      ${{ secrets.TURN_IP2 }}
        run: |
          set -e
          # Render template locally (requires envsubst from gettext-base)
          sudo apt-get update -y >/dev/null 2>&1 || true
          sudo apt-get install -y gettext-base >/dev/null 2>&1 || true
          export TURN_SECRET TURN_IP TURN_IP2
          TMP_CFG=$(mktemp)
          RENDER_TPL=$(mktemp)
          # convert {{VAR}} -> ${VAR} for envsubst, then render
          sed -E 's/\{\{([A-Z0-9_]+)\}\}/\$\{\1\}/g' .github/workflows/turnserver.conf > "$RENDER_TPL"
          envsubst < "$RENDER_TPL" > "$TMP_CFG"

          echo "--- rendered turnserver.conf ---"
          sed -e '/^$/d' -e '/^#/d' "$TMP_CFG"

          # upload and install on server
          scp -P "${SSH_PORT:-22}" "$TMP_CFG" "${SSH_USER}@${SSH_HOST}:/tmp/turnserver.conf"
          ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" "\
            set -e; \
            echo \"$SUDO_PASSWORD\" | sudo -S install -m 0644 /tmp/turnserver.conf /etc/turnserver.conf; \
            echo \"--- /etc/turnserver.conf (effective) ---\"; \
            egrep -v '^#|^$' /etc/turnserver.conf || true; \
            echo \"$SUDO_PASSWORD\" | sudo -S systemctl restart coturn; \
            sudo systemctl status coturn --no-pager -l | head -n 30; \
          "

      - name: Upload and enable nginx site (from repo)
        if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
        env:
          SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
        run: |
          # upload site config from repo to a temp path on the server
          scp -P "${SSH_PORT:-22}" .github/workflows/call.zababba.com.conf "${SSH_USER}@${SSH_HOST}":/tmp/call-final.conf
          # move into place, replace the active site, and reload nginx non-interactively
          ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" "\
            set -e; \
            echo \"$SUDO_PASSWORD\" | sudo -S mv /tmp/call-final.conf /etc/nginx/sites-available/call-final.conf; \
            # remove any older call* site links to avoid duplicate/conflicting server blocks
            echo \"$SUDO_PASSWORD\" | sudo -S bash -lc 'rm -f /etc/nginx/sites-enabled/call*.conf || true'; \
            echo \"$SUDO_PASSWORD\" | sudo -S ln -sfn /etc/nginx/sites-available/call-final.conf /etc/nginx/sites-enabled/call-final.conf; \
            echo \"$SUDO_PASSWORD\" | sudo -S nginx -t; \
            echo \"$SUDO_PASSWORD\" | sudo -S systemctl reload nginx; \
          "

      # (Опционально) Перекатить статику атомарно через симлинк, если используется версияция релизов
      # Раскомментируй и адаптируй при необходимости
      # - name: Atomic switch (optional)
      #   if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
      #   run: |
      #     ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" '
      #       set -e
      #       releases="${DEPLOY_PATH%/}/releases"
      #       current="${DEPLOY_PATH%/}/current"
      #       ts=$(date +%Y%m%d%H%M%S)
      #       mkdir -p "$releases/$ts"
      #       rsync -az --delete "${DEPLOY_PATH%/}/" "$releases/$ts/"
      #       ln -sfn "$releases/$ts" "$current"
      #     '

      # (Опционально) Перезапуск systemd-сервиса сигнального сервера,
      # если укажешь SERVICE_NAME в секретах (например, "zvonilka-signal.service")
      - name: Restart signaling service (optional)
        if: env.SERVICE_NAME != '' && env.SSH_HOST != ''
        env:
          SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
        run: |
          ssh -p "${SSH_PORT:-22}" -tt "${SSH_USER}@${SSH_HOST}" "
            set -e
            if [ -n '${SERVICE_NAME}' ] && systemctl list-unit-files | grep -q '^${SERVICE_NAME}\.service'; then
              echo \"$SUDO_PASSWORD\" | sudo -S -p '' systemctl daemon-reload || true
              echo \"$SUDO_PASSWORD\" | sudo -S -p '' systemctl restart '${SERVICE_NAME}'
              echo \"$SUDO_PASSWORD\" | sudo -S -p '' systemctl status '${SERVICE_NAME}' --no-pager -l || true
            else
              echo 'systemd unit ${SERVICE_NAME} not found; skipping systemctl restart'
            fi
          "

      - name: Restart PM2 process (fallback if no systemd)
        if: env.SSH_HOST != ''
        run: |
          ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" "\
            set -e; \
            cd '${DEPLOY_PATH}'; \
            if [ -f ecosystem.config.js ]; then \
              pm2 start ecosystem.config.js --only call-signal --update-env || pm2 start ecosystem.config.js --update-env; \
            else \
              pm2 restart call-signal --update-env || pm2 start server.js --name call-signal; \
            fi; \
            pm2 save || true; \
            pm2 status call-signal || true
          "

      # Небольшая проверка, что index.html на месте
      - name: Verify remote files
        if: env.SSH_HOST != '' && env.DEPLOY_PATH != ''
        run: |
          ssh -p "${SSH_PORT:-22}" "${SSH_USER}@${SSH_HOST}" "ls -lah '${DEPLOY_PATH}' | head -n 50"
